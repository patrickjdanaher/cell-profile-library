out[, "sd", tiss] = apply(log2(pmax(counts, 1))[, tissue == tiss], 1, sd)
}
if (is.element("mean", stats)) {
out[, "mean", tiss] = apply(log2(pmax(counts, 1))[, tissue == tiss], 1, mean)
}
}
dim(out)
head(out[,,1])
stats = c("mean", "sd", "gini", "spacecor.o2")
# init results array:
out = array(NA, dim = c(nrow(counts), length(stats), length(unique(tissue))),
dimnames = list(rownames(counts), stats, unique(tissue)))
# calc all specified stats:
for (tiss in unique(tissue)) {
if (is.element("gini", stats)) {
out[, "gini", tiss] = apply(counts[, tissue == tiss], 1, gini)
}
if ((length(x) == ncol(counts)) & (length(y) == ncol(counts))) {
if (is.element("spacecor.o1", stats)) {
out[, "spacecor.o1", tiss] = apply(counts[, tissue == tiss], 1, spacecor, x, y, order = 1, scale = "log")
}
if (is.element("spacecor.o2", stats)) {
out[, "spacecor.o2", tiss] = apply(counts[, tissue == tiss], 1, spacecor, x, y,  order = 2, scale = "log")
}
}
if (is.element("sd", stats)) {
out[, "sd", tiss] = apply(log2(pmax(counts, 1))[, tissue == tiss], 1, sd)
}
if (is.element("mean", stats)) {
out[, "mean", tiss] = apply(log2(pmax(counts, 1))[, tissue == tiss], 1, mean)
}
}
head(out[,,1])
pairs(out[,,1])
# also calculate mean stats:
meanstats = apply(out, 1:2, mean)
dim(meanstats)
head(meanstats)
# also calculate mean stats:
meanstats = apply(out, 1:2, mean)
# append cross-tissue stats:
if (length(unique(tissue)) > 1) {
tot.var = apply(log2(pmax(counts, 1)), 1, var)
var.within = meanstats[, "sd"]^2
prop.var.from.tissue = cbind(meanstats, 1 - (var.within / tot.var))
meanstats = cbind(meanstats, prop.var.from.tissue)
}
meanstats[1:5,]
#' Wrapper function that computes multiple summary stats over a data matrix. Some statistics
#'  are spatial in nature and require xy info.
#'
#' @param counts Matrix of linear-scale counts, with genes in rows and segments in columns. Assumed to be normalized.
#' @param x x-coordinates of segments
#' @param y y-coordinates of segments
#' @param tissue vector of tissue IDs. If NULL, it's assumed that there's only one tissue in the matrix.
#' @param stats Vector of statistics to be computed
#' @return If one tissue, a matrix of summary statistics of genes * stats. If multiple tissues, a list
#'  of such matrices.
summarystats <- function(counts, x = NULL, y = NULL, tissue) {  #, stats = c("mean", "sd", "gini", "spacecor.o2")
# init results array:
stats = c("mean", "sd", "gini", "spacecor.o2")
stats.per.tissue = array(NA, dim = c(nrow(counts), length(stats), length(unique(tissue))),
dimnames = list(rownames(counts), stats, unique(tissue)))
# calc all specified stats:
for (tiss in unique(tissue)) {
stats.per.tissue[, "sd", tiss] = apply(log2(pmax(counts, 1))[, tissue == tiss], 1, sd)
stats.per.tissue[, "mean", tiss] = apply(log2(pmax(counts, 1))[, tissue == tiss], 1, mean)
stats.per.tissue[, "gini", tiss] = apply(counts[, tissue == tiss], 1, gini)
# spatial stats, which require xy cooords:
if ((length(x) == ncol(counts)) & (length(y) == ncol(counts))) {
stats.per.tissue[, "spacecor.o1", tiss] = apply(counts[, tissue == tiss], 1, spacecor, x, y, order = 1, scale = "log")
stats.per.tissue[, "spacecor.o2", tiss] = apply(counts[, tissue == tiss], 1, spacecor, x, y,  order = 2, scale = "log")
}
}
# also calculate mean stats:
meanstats = apply(stats.per.tissue, 1:2, mean)
# append cross-tissue stats:
if (length(unique(tissue)) > 1) {
tot.var = apply(log2(pmax(counts, 1)), 1, var)
var.within = meanstats[, "sd"]^2
prop.var.from.tissue = cbind(meanstats, 1 - (var.within / tot.var))
meanstats = cbind(meanstats, prop.var.from.tissue)
}
if (length(unique(tissue)) > 1) {
out = list(stats = meanstats, stats.per.tissue = stats.per.tissue)
}
if (length(unique(tissue)) == 1) {
out = stats.per.tissue
}
return(out)
}
head(summarystats(counts, x = x, y = y, tissue) )
#' Wrapper function that computes multiple summary stats over a data matrix. Some statistics
#'  are spatial in nature and require xy info.
#'
#' @param counts Matrix of linear-scale counts, with genes in rows and segments in columns. Assumed to be normalized.
#' @param x x-coordinates of segments
#' @param y y-coordinates of segments
#' @param tissue vector of tissue IDs. If NULL, it's assumed that there's only one tissue in the matrix.
#' @param stats Vector of statistics to be computed
#' @return If one tissue, a matrix of summary statistics of genes * stats. If multiple tissues, a list
#'  of such matrices.
summarystats <- function(counts, x = NULL, y = NULL, tissue) {  #, stats = c("mean", "sd", "gini", "spacecor.o2")
# init results array:
stats = c("mean", "sd", "gini", "spacecor.o2", "spacecor.o1")
stats.per.tissue = array(NA, dim = c(nrow(counts), length(stats), length(unique(tissue))),
dimnames = list(rownames(counts), stats, unique(tissue)))
# calc all specified stats:
for (tiss in unique(tissue)) {
stats.per.tissue[, "sd", tiss] = apply(log2(pmax(counts, 1))[, tissue == tiss], 1, sd)
stats.per.tissue[, "mean", tiss] = apply(log2(pmax(counts, 1))[, tissue == tiss], 1, mean)
stats.per.tissue[, "gini", tiss] = apply(counts[, tissue == tiss], 1, gini)
# spatial stats, which require xy cooords:
if ((length(x) == ncol(counts)) & (length(y) == ncol(counts))) {
stats.per.tissue[, "spacecor.o1", tiss] = apply(counts[, tissue == tiss], 1, spacecor, x, y, order = 1, scale = "log")
stats.per.tissue[, "spacecor.o2", tiss] = apply(counts[, tissue == tiss], 1, spacecor, x, y,  order = 2, scale = "log")
}
}
# also calculate mean stats:
meanstats = apply(stats.per.tissue, 1:2, mean)
# append cross-tissue stats:
if (length(unique(tissue)) > 1) {
tot.var = apply(log2(pmax(counts, 1)), 1, var)
var.within = meanstats[, "sd"]^2
prop.var.from.tissue = cbind(meanstats, 1 - (var.within / tot.var))
meanstats = cbind(meanstats, prop.var.from.tissue)
}
if (length(unique(tissue)) > 1) {
out = list(stats = meanstats, stats.per.tissue = stats.per.tissue)
}
if (length(unique(tissue)) == 1) {
out = stats.per.tissue
}
return(out)
}
head(summarystats(counts, x = x, y = y, tissue) )
temp = (summarystats(counts, x = x, y = y, tissue) )
di(temp)
str(temp)
#' Wrapper function that computes multiple summary stats over a data matrix. Some statistics
#'  are spatial in nature and require xy info.
#'
#' @param counts Matrix of linear-scale counts, with genes in rows and segments in columns. Assumed to be normalized.
#' @param x x-coordinates of segments
#' @param y y-coordinates of segments
#' @param tissue vector of tissue IDs. If NULL, it's assumed that there's only one tissue in the matrix.
#' @param stats Vector of statistics to be computed
#' @return If one tissue, a matrix of summary statistics of genes * stats. If multiple tissues, a list
#'  of such matrices.
summarystats <- function(counts, x = NULL, y = NULL, tissue) {  #, stats = c("mean", "sd", "gini", "spacecor.o2")
# init results array:
stats = c("mean", "sd", "gini", "spacecor.o2", "spacecor.o1")
stats.per.tissue = array(NA, dim = c(nrow(counts), length(stats), length(unique(tissue))),
dimnames = list(rownames(counts), stats, unique(tissue)))
# calc all specified stats:
for (tiss in unique(tissue)) {
stats.per.tissue[, "sd", tiss] = apply(log2(pmax(counts, 1))[, tissue == tiss], 1, sd)
stats.per.tissue[, "mean", tiss] = apply(log2(pmax(counts, 1))[, tissue == tiss], 1, mean)
stats.per.tissue[, "gini", tiss] = apply(counts[, tissue == tiss], 1, gini)
# spatial stats, which require xy cooords:
if ((length(x) == ncol(counts)) & (length(y) == ncol(counts))) {
stats.per.tissue[, "spacecor.o1", tiss] = apply(counts[, tissue == tiss], 1, spacecor, x, y, order = 1, scale = "log")
stats.per.tissue[, "spacecor.o2", tiss] = apply(counts[, tissue == tiss], 1, spacecor, x, y,  order = 2, scale = "log")
}
}
# also calculate mean stats:
meanstats = apply(stats.per.tissue, 1:2, mean)
# append cross-tissue stats:
if (length(unique(tissue)) > 1) {
tot.var = apply(log2(pmax(counts, 1)), 1, var)
var.within = meanstats[, "sd"]^2
prop.var.from.tissue = cbind(meanstats, 1 - (var.within / tot.var))
meanstats = cbind(meanstats, prop.var.from.tissue)
}
if (length(unique(tissue)) > 1) {
out = list(stats = meanstats, stats.per.tissue = stats.per.tissue)
}
if (length(unique(tissue)) == 1) {
out = stats.per.tissue[, , 1]
}
return(out)
}
temp = (summarystats(counts[1:5, ], x = x, y = y, tissue) )
temp
#' Wrapper function that computes multiple summary stats over a data matrix. Some statistics
#'  are spatial in nature and require xy info.
#'
#' @param counts Matrix of linear-scale counts, with genes in rows and segments in columns. Assumed to be normalized.
#' @param x x-coordinates of segments
#' @param y y-coordinates of segments
#' @param tissue vector of tissue IDs. If NULL, it's assumed that there's only one tissue in the matrix.
#' @param stats Vector of statistics to be computed
#' @return If one tissue, a matrix of summary statistics of genes * stats. If multiple tissues, a list
#'  of such matrices.
summarystats <- function(counts, x = NULL, y = NULL, tissue) {  #, stats = c("mean", "sd", "gini", "spacecor.o2")
# for log-scale stats: choose a non-zero value:
epsilon = min(counts[counts > 0])
# init results array:
stats = c("mean", "sd", "gini", "spacecor.o2", "spacecor.o1")
stats.per.tissue = array(NA, dim = c(nrow(counts), length(stats), length(unique(tissue))),
dimnames = list(rownames(counts), stats, unique(tissue)))
# calc all specified stats:
for (tiss in unique(tissue)) {
stats.per.tissue[, "sd", tiss] = apply(log2(pmax(counts, epsilon))[, tissue == tiss], 1, sd)
stats.per.tissue[, "mean", tiss] = apply(log2(pmax(counts, epsilon))[, tissue == tiss], 1, mean)
stats.per.tissue[, "gini", tiss] = apply(counts[, tissue == tiss], 1, gini)
# spatial stats, which require xy cooords:
if ((length(x) == ncol(counts)) & (length(y) == ncol(counts))) {
stats.per.tissue[, "spacecor.o1", tiss] = apply(counts[, tissue == tiss], 1, spacecor, x, y, order = 1, scale = "log")
stats.per.tissue[, "spacecor.o2", tiss] = apply(counts[, tissue == tiss], 1, spacecor, x, y,  order = 2, scale = "log")
}
}
# also calculate mean stats:
meanstats = apply(stats.per.tissue, 1:2, mean)
# append cross-tissue stats:
if (length(unique(tissue)) > 1) {
tot.var = apply(log2(pmax(counts, 1)), 1, var)
var.within = meanstats[, "sd"]^2
prop.var.from.tissue = cbind(meanstats, 1 - (var.within / tot.var))
meanstats = cbind(meanstats, prop.var.from.tissue)
}
if (length(unique(tissue)) > 1) {
out = list(stats = meanstats, stats.per.tissue = stats.per.tissue)
}
if (length(unique(tissue)) == 1) {
out = stats.per.tissue[, , 1]
}
return(out)
}
(summarystats(counts[1:5, ], x = x, y = y, tissue) )
gini(1:10)
#' gini coefficient
#'
#' calculates the gini coefficient
#' @param count vector of counts
#'
gini <- function (count)
{
weights = rep(1, length = length(count))
o <- order(count)
count <- count[o]
weights <- weights[o]/sum(weights)
p <- cumsum(weights)
nu <- cumsum(weights * count)
n <- length(nu)
nu <- nu/nu[n]
sum(nu[-1] * p[-n]) - sum(nu[-n] * p[-1])
}
gini(1:10)
(summarystats(counts[1:5, ], x = x, y = y, tissue = rep(c("a", "b"), each = 100)[1:ncol(counts)]) )
rep(c("a", "b"), each = 100)[1:ncol(counts)]
rep(c("a", "b"), each = 200)[1:ncol(counts)]
rep(c("a", "b"), each = 200)[1:ncol(counts)]
(summarystats(counts[1:5, ], x = x, y = y, tissue = rep(c("a", "b"), each = 200)[1:ncol(counts)]) )
tissue = rep(c("a", "b"), each = 200)[1:ncol(counts)]
# for log-scale stats: choose a non-zero value:
epsilon = min(counts[counts > 0])
# init results array:
stats = c("mean", "sd", "gini", "spacecor.o2", "spacecor.o1")
stats.per.tissue = array(NA, dim = c(nrow(counts), length(stats), length(unique(tissue))),
dimnames = list(rownames(counts), stats, unique(tissue)))
# calc all specified stats:
for (tiss in unique(tissue)) {
stats.per.tissue[, "sd", tiss] = apply(log2(pmax(counts, epsilon))[, tissue == tiss], 1, sd)
stats.per.tissue[, "mean", tiss] = apply(log2(pmax(counts, epsilon))[, tissue == tiss], 1, mean)
stats.per.tissue[, "gini", tiss] = apply(counts[, tissue == tiss], 1, gini)
# spatial stats, which require xy cooords:
if ((length(x) == ncol(counts)) & (length(y) == ncol(counts))) {
stats.per.tissue[, "spacecor.o1", tiss] = apply(counts[, tissue == tiss], 1, spacecor, x, y, order = 1, scale = "log")
stats.per.tissue[, "spacecor.o2", tiss] = apply(counts[, tissue == tiss], 1, spacecor, x, y,  order = 2, scale = "log")
}
}
tiss
dim(counts)
apply(log2(pmax(counts, epsilon))[, tissue == tiss], 1, sd)
stats.per.tissue[, "sd", tiss] = apply(log2(pmax(counts, epsilon))[, tissue == tiss], 1, sd)
stats.per.tissue[, "mean", tiss] = apply(log2(pmax(counts, epsilon))[, tissue == tiss], 1, mean)
stats.per.tissue[, "gini", tiss] = apply(counts[, tissue == tiss], 1, gini)
# spatial stats, which require xy cooords:
if ((length(x) == ncol(counts)) & (length(y) == ncol(counts))) {
stats.per.tissue[, "spacecor.o1", tiss] = apply(counts[, tissue == tiss], 1, spacecor,
x[tissue == tiss], y[tissue == tiss],
order = 1, scale = "log")
stats.per.tissue[, "spacecor.o2", tiss] = apply(counts[, tissue == tiss], 1, spacecor,
x[tissue == tiss], y[tissue == tiss],
order = 2, scale = "log")
}
#' Wrapper function that computes multiple summary stats over a data matrix. Some statistics
#'  are spatial in nature and require xy info.
#'
#' @param counts Matrix of linear-scale counts, with genes in rows and segments in columns. Assumed to be normalized.
#' @param x x-coordinates of segments
#' @param y y-coordinates of segments
#' @param tissue vector of tissue IDs. If NULL, it's assumed that there's only one tissue in the matrix.
#' @param stats Vector of statistics to be computed
#' @return If one tissue, a matrix of summary statistics of genes * stats. If multiple tissues, a list
#'  of such matrices.
summarystats <- function(counts, x = NULL, y = NULL, tissue) {  #, stats = c("mean", "sd", "gini", "spacecor.o2")
# for log-scale stats: choose a non-zero value:
epsilon = min(counts[counts > 0])
# init results array:
stats = c("mean", "sd", "gini", "spacecor.o2", "spacecor.o1")
stats.per.tissue = array(NA, dim = c(nrow(counts), length(stats), length(unique(tissue))),
dimnames = list(rownames(counts), stats, unique(tissue)))
# calc all specified stats:
for (tiss in unique(tissue)) {
stats.per.tissue[, "sd", tiss] = apply(log2(pmax(counts, epsilon))[, tissue == tiss], 1, sd)
stats.per.tissue[, "mean", tiss] = apply(log2(pmax(counts, epsilon))[, tissue == tiss], 1, mean)
stats.per.tissue[, "gini", tiss] = apply(counts[, tissue == tiss], 1, gini)
# spatial stats, which require xy cooords:
if ((length(x) == ncol(counts)) & (length(y) == ncol(counts))) {
stats.per.tissue[, "spacecor.o1", tiss] = apply(counts[, tissue == tiss], 1, spacecor,
x[tissue == tiss], y[tissue == tiss],
order = 1, scale = "log")
stats.per.tissue[, "spacecor.o2", tiss] = apply(counts[, tissue == tiss], 1, spacecor,
x[tissue == tiss], y[tissue == tiss],
order = 2, scale = "log")
}
}
# also calculate mean stats:
meanstats = apply(stats.per.tissue, 1:2, mean)
# append cross-tissue stats:
if (length(unique(tissue)) > 1) {
tot.var = apply(log2(pmax(counts, 1)), 1, var)
var.within = meanstats[, "sd"]^2
prop.var.from.tissue = cbind(meanstats, 1 - (var.within / tot.var))
meanstats = cbind(meanstats, prop.var.from.tissue)
}
if (length(unique(tissue)) > 1) {
out = list(stats = meanstats, stats.per.tissue = stats.per.tissue)
}
if (length(unique(tissue)) == 1) {
out = stats.per.tissue[, , 1]
}
return(out)
}
(summarystats(counts[1:5, ], x = x, y = y, tissue = rep(c("a", "b"), each = 200)[1:ncol(counts)]) )
# also calculate mean stats:
meanstats = apply(stats.per.tissue, 1:2, mean)
dim(meanstats)
head(meanstats)
dim(stats.per.tissue)
# init results array:
stats = c("mean", "sd", "gini", "spacecor.o2", "spacecor.o1")
stats.per.tissue = array(NA, dim = c(nrow(counts), length(stats), length(unique(tissue))),
dimnames = list(rownames(counts), stats, unique(tissue)))
# calc all specified stats:
for (tiss in unique(tissue)) {
stats.per.tissue[, "sd", tiss] = apply(log2(pmax(counts, epsilon))[, tissue == tiss], 1, sd)
stats.per.tissue[, "mean", tiss] = apply(log2(pmax(counts, epsilon))[, tissue == tiss], 1, mean)
stats.per.tissue[, "gini", tiss] = apply(counts[, tissue == tiss], 1, gini)
# spatial stats, which require xy cooords:
if ((length(x) == ncol(counts)) & (length(y) == ncol(counts))) {
stats.per.tissue[, "spacecor.o1", tiss] = apply(counts[, tissue == tiss], 1, spacecor,
x[tissue == tiss], y[tissue == tiss],
order = 1, scale = "log")
stats.per.tissue[, "spacecor.o2", tiss] = apply(counts[, tissue == tiss], 1, spacecor,
x[tissue == tiss], y[tissue == tiss],
order = 2, scale = "log")
}
}
# also calculate mean stats:
meanstats = apply(stats.per.tissue, 1:2, mean)
head(meanstats)
tot.var = apply(log2(pmax(counts, 1)), 1, var)
var.within = meanstats[, "sd"]^2
prop.var.from.tissue = cbind(meanstats, 1 - (var.within / tot.var))
prop.var.from.tissue
dim(tot.var)
str(tot.var)
str(var.within)
prop.var.from.tissue = 1 - (var.within / tot.var)
meanstats = cbind(meanstats, prop.var.from.tissue)
head(meanstats)
#' Wrapper function that computes multiple summary stats over a data matrix. Some statistics
#'  are spatial in nature and require xy info.
#'
#' @param counts Matrix of linear-scale counts, with genes in rows and segments in columns. Assumed to be normalized.
#' @param x x-coordinates of segments
#' @param y y-coordinates of segments
#' @param tissue vector of tissue IDs. If NULL, it's assumed that there's only one tissue in the matrix.
#' @param stats Vector of statistics to be computed
#' @return If one tissue, a matrix of summary statistics of genes * stats. If multiple tissues, a list
#'  of such matrices.
summarystats <- function(counts, x = NULL, y = NULL, tissue) {  #, stats = c("mean", "sd", "gini", "spacecor.o2")
# for log-scale stats: choose a non-zero value:
epsilon = min(counts[counts > 0])
# init results array:
stats = c("mean", "sd", "gini", "spacecor.o2", "spacecor.o1")
stats.per.tissue = array(NA, dim = c(nrow(counts), length(stats), length(unique(tissue))),
dimnames = list(rownames(counts), stats, unique(tissue)))
# calc all specified stats:
for (tiss in unique(tissue)) {
stats.per.tissue[, "sd", tiss] = apply(log2(pmax(counts, epsilon))[, tissue == tiss], 1, sd)
stats.per.tissue[, "mean", tiss] = apply(log2(pmax(counts, epsilon))[, tissue == tiss], 1, mean)
stats.per.tissue[, "gini", tiss] = apply(counts[, tissue == tiss], 1, gini)
# spatial stats, which require xy cooords:
if ((length(x) == ncol(counts)) & (length(y) == ncol(counts))) {
stats.per.tissue[, "spacecor.o1", tiss] = apply(counts[, tissue == tiss], 1, spacecor,
x[tissue == tiss], y[tissue == tiss],
order = 1, scale = "log")
stats.per.tissue[, "spacecor.o2", tiss] = apply(counts[, tissue == tiss], 1, spacecor,
x[tissue == tiss], y[tissue == tiss],
order = 2, scale = "log")
}
}
# also calculate mean stats:
meanstats = apply(stats.per.tissue, 1:2, mean)
# append cross-tissue stats:
if (length(unique(tissue)) > 1) {
tot.var = apply(log2(pmax(counts, 1)), 1, var)
var.within = meanstats[, "sd"]^2
prop.var.from.tissue = 1 - (var.within / tot.var)
meanstats = cbind(meanstats, prop.var.from.tissue)
}
if (length(unique(tissue)) > 1) {
out = list(stats = meanstats, stats.per.tissue = stats.per.tissue)
}
if (length(unique(tissue)) == 1) {
out = stats.per.tissue[, , 1]
}
return(out)
}
(summarystats(counts[1:5, ], x = x, y = y, tissue = rep(c("a", "b"), each = 200)[1:ncol(counts)]) )
(summarystats(counts, x = x, y = y, tissue = rep(c("a", "b"), each = 200)[1:ncol(counts)]) )
var.within = rowMeans(stats.per.tissue[, "sd", ]^2)
var.within
#' Wrapper function that computes multiple summary stats over a data matrix. Some statistics
#'  are spatial in nature and require xy info.
#'
#' @param counts Matrix of linear-scale counts, with genes in rows and segments in columns. Assumed to be normalized.
#' @param x x-coordinates of segments
#' @param y y-coordinates of segments
#' @param tissue vector of tissue IDs. If NULL, it's assumed that there's only one tissue in the matrix.
#' @param stats Vector of statistics to be computed
#' @return If one tissue, a matrix of summary statistics of genes * stats. If multiple tissues, a list
#'  of such matrices.
summarystats <- function(counts, x = NULL, y = NULL, tissue) {  #, stats = c("mean", "sd", "gini", "spacecor.o2")
# for log-scale stats: choose a non-zero value:
epsilon = min(counts[counts > 0])
# init results array:
stats = c("mean", "sd", "gini", "spacecor.o2", "spacecor.o1")
stats.per.tissue = array(NA, dim = c(nrow(counts), length(stats), length(unique(tissue))),
dimnames = list(rownames(counts), stats, unique(tissue)))
# calc all specified stats:
for (tiss in unique(tissue)) {
stats.per.tissue[, "sd", tiss] = apply(log2(pmax(counts, epsilon))[, tissue == tiss], 1, sd)
stats.per.tissue[, "mean", tiss] = apply(log2(pmax(counts, epsilon))[, tissue == tiss], 1, mean)
stats.per.tissue[, "gini", tiss] = apply(counts[, tissue == tiss], 1, gini)
# spatial stats, which require xy cooords:
if ((length(x) == ncol(counts)) & (length(y) == ncol(counts))) {
stats.per.tissue[, "spacecor.o1", tiss] = apply(counts[, tissue == tiss], 1, spacecor,
x[tissue == tiss], y[tissue == tiss],
order = 1, scale = "log")
stats.per.tissue[, "spacecor.o2", tiss] = apply(counts[, tissue == tiss], 1, spacecor,
x[tissue == tiss], y[tissue == tiss],
order = 2, scale = "log")
}
}
# also calculate mean stats:
meanstats = apply(stats.per.tissue, 1:2, mean)
# append cross-tissue stats:
if (length(unique(tissue)) > 1) {
tot.var = apply(log2(pmax(counts, 1)), 1, var)
var.within = rowMeans(stats.per.tissue[, "sd", ]^2)
prop.var.from.tissue = 1 - (var.within / tot.var)
meanstats = cbind(meanstats, prop.var.from.tissue)
}
if (length(unique(tissue)) > 1) {
out = list(stats = meanstats, stats.per.tissue = stats.per.tissue)
}
if (length(unique(tissue)) == 1) {
out = stats.per.tissue[, , 1]
}
return(out)
}
temp = (summarystats(counts, x = x, y = y, tissue = rep(c("a", "b"), each = 200)[1:ncol(counts)]) )
str(temp)
setwd("~/cell-profile-library/profile_matrices")
dir)()
dir()
substr(dir(), 1, nchar(dir()) - 4)
substr(dir(), 1, nchar(dir()) - 10)
substr(dir(), 1, nchar(dir()) - 11)
substr(dir(), 1, nchar(dir()) - 7)
paste0(substr(dir(), 1, nchar(dir()) - 7), collapse = ",")
paste0(substr(dir(), 1, nchar(dir()) - 7), collapse = "\',\'")
paste0(substr(dir(), 1, nchar(dir()) - 7), collapse = "\', \'")
repolocation = "https://github.com/patrickjdanaher/cell-profile-library/profile_matrices/"
?pheatmap
# if X is given as a matrix from the cell profile library, download it.
librarymatrixnames = c('Airway_Epithelium', 'Atlas_Adult_Retina_10x', 'Census_Adult_Immune_10x',
'Census_Newborn_Blood_10x', 'Diff_Fetal_Neuron_SS2', 'FetalMaternal_Adult_Blood_10x',
'FetalMaternal_Adult_Blood_SS2', 'FetalMaternal_Adult_Decidua_10x',
'FetalMaternal_Adult_Decidua_SS2', 'FetalMaternal_Fetal_Placenta_10x',
'Human_brain', 'Human_Cell_Landscape', 'IBD_Adult_Colon_10x',
'Landscape_Adult_Liver_10x', 'Mouse_Brain', 'Profiling_Adult_BoneMarrow_10x',
'Reprogram_Embryo_Dendritic_10x', 'Sensitivity_Adult_Esophagus_10x',
'Sensitivity_Adult_Lung_10x', 'Sensitivity_Adult_Spleen_10x',
'Somatic_Adult_Pancreas_SS2', 'SpatioTemporal_Adult_Kidney_10x',
'SpatioTemporal_Fetal_Kidney_10x', 'Tcell_Adult_Blood_10x',
'Tcell_Adult_BoneMarrow_10x', 'Tcell_Adult_Lung_10x', 'Tcell_Adult_LymphNode_10x')
paste0(librarymatrixnames, sep = "\n")
paste0(librarymatrixnames, sep = *)
paste0(librarymatrixnames, sep = "*")
paste0(librarymatrixnames, sep = " #' * ")
paste0(librarymatrixnames, sep = " #' * ", quote = "")
paste0(librarymatrixnames, collapse = " #' * ")
paste0(librarymatrixnames, collapse = "  * ")
is.matrix(NULL)
library(InSituSort)
head(safeTME)
